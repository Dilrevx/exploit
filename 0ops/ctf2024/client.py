import hashlib
import string
from itertools import product
import pickle
from typing import Dict


def crackPow(fmtStr: str):
    # fmtStr = "PoW Challenge: SHA256(solution + 'challenge') must start with 'prefix'."
    _, challenge, _, prefix, _ = fmtStr.split("'")
    charSet = string.digits + string.ascii_lowercase
    searchSpace = ("".join(char) for char in product(charSet, repeat=64 - len(challenge)))

    for solution in searchSpace:
        hash = hashlib.sha256((solution + challenge).encode()).hexdigest()
        if hash.startswith(prefix):
            print(f"Solution found: {solution}")
            return solution

import base64
from PIL import Image, ImageTk
import tkinter as tk
import socket
from pwn import *
def getRoundImg(sh: process) -> bytes:
    sh.recvline_startswith("Round")
    base64Img = sh.recvline(keepends=False)
    img = base64.b64decode(base64Img)
    return img

def displayImg(imgPath: str):
    import subprocess

    subprocess.run(['code', imgPath])

def checkRealImg(update = False, kv = dict()) -> Dict[str, bool]:
    cacheDir = 'cache'
    picklePath = f'{cacheDir}/hash2real.pkl'
    hash2real = {}
    if os.path.exists(picklePath):
        with open(picklePath, 'rb') as f:
            hash2real = pickle.load(f)
    if update:
        hash2real.update(kv)
    try:
        for img in os.listdir(cacheDir):
            if not img.endswith('.png'):
                continue

            hash = img[:-4]
            if hash in hash2real:
                continue

            displayImg(f'{cacheDir}/{img}')
            isReal = input(f"Is {img} real? (y/n)").strip().capitalize()
            assert isReal and isReal in 'YN', "Invalid input = " + isReal

            hash2real[hash] = isReal == 'Y'
    except:
        pass
    finally:
        with open(picklePath, 'wb') as f:
            pickle.dump(hash2real, f)
    return hash2real


print(checkRealImg())



def main():
    def getProxySocket(ncCmd: str):
        host, domain, port = ncCmd.split()[4:]
        socket_ = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        hh, hp = host.split(':')
        socket_.connect((hh, int(hp)))
        
        connect_request = "CONNECT {h}:{p} HTTP/1.1\r\nHost: {h}:{p}\r\n\r\n".format(h=domain, p=port)
        socket_.sendall(connect_request.encode())
        
        # print(socket_.recv(1024).decode())
        assert socket_.recv(1024).decode().startswith('HTTP/1.1 200'), "Proxy connection failed."
        # socket_.recv(1024)
        return socket_

    db = checkRealImg()
    ncCmd = "nc -X connect -x instance.penguin.0ops.sjtu.cn:18081 wmv33x3cf7keg2qy 1"
    socket_ = getProxySocket(ncCmd)
    sh = remote.fromsocket(socket_)

    challRequest = sh.recvline_startswith("PoW")
    print(challRequest)
    solution = crackPow(challRequest.decode())
    sh.sendline(solution)

    imgs = []
    for round in range(1, 21):
        img = getRoundImg(sh)
        imgs.append(img)
    print("20 x img recv with set.size =",len(set(imgs)))

    os.makedirs('cache', exist_ok=True)
    hashs = list(map(lambda x: hashlib.sha256(x).hexdigest(), imgs))
    
    assert len(set(hashs)) == len(set(imgs)), "hash collision detected"
    '''
    try a return
    '''
    try:
        ret = []
        for i, (img, hash) in enumerate(zip(imgs, hashs)):
            ret.append(db[hash])
        sh.recvuntil("(Y/N): ")
        ans = ''.join('Y' if x else 'N' for x in ret)
        print("[SEND] = ", ans)
        sh.sendline(ans.encode())

        # TODO: check error
        result = sh.recvline(keepends=False)
        print(result)
        errRound = int(result.decode().split()[4].replace('.', '')) -1 
        assert errRound >= 0
        print("[Error round] = ", errRound)
        checkRealImg(update=True, kv={hashs[errRound]: not db[hashs[errRound]]})
    except KeyError:
        for i, (img, hash) in enumerate(zip(imgs, hashs)):
            if hash in db:
                with open('cache/{}.png'.format(hash), 'rb') as f:
                    assert f.read() == img, "hash collision detected"
                continue
            else:
                with open('cache/{}.png'.format(hash), 'wb') as f:
                    f.write((img))
        checkRealImg()


    # sh.interactive()

while True:
    try:
        main()
    except Exception as e:
        pass
    finally:
        print("Restarting...")