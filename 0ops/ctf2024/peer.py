from pwn import *


def encrypt_read(buf: bytes):
    buf = bytearray(buf)
    rax = len(buf)
    next_rax = 8 * ((rax >> 3) + 1)
    buf.ljust(56)
    for i in range(0, next_rax + 6, 8):
        bufi = buf[i : i + 8]  # little endian: bufi[0] is the least significant byte
        _buf = bufi
        _buf[0] = bufi[5]
        _buf[5] = bufi[0]
        _buf[1] = bufi[7]
        _buf[7] = bufi[1]
        _buf[2] = bufi[6]
        _buf[6] = bufi[2]

        for j in range(0, min(rax - i, 8)):
            _buf[j] -= j + i

        _buf[3], _buf[4] = _buf[4], _buf[3]

        buf[i:i+8] = _buf
    return buf

def _encrypt_read(buf: bytes):
    buf = bytearray(buf)
    rax = len(buf)
    for i in range(0, rax, 8):
        bufi = buf[i : i + 8]  # little endian: bufi[0] is the least significant byte
        _buf = bufi.copy()
        _buf[0] = bufi[5]
        _buf[5] = bufi[0]
        _buf[1] = bufi[7]
        _buf[7] = bufi[1]
        _buf[2] = bufi[6]
        _buf[6] = bufi[2]

        for j in range(0, min(rax - i, 8)):
            _buf[j] = (_buf[j] - i-j + 0x100) & 0xff

        _buf[3], _buf[4] = _buf[4], _buf[3]
        buf[i:i+8] = _buf
    return buf

def decrypt_read(buf: bytes):
    buf = bytearray(buf)
    rax = len(buf)
    for i in range(0, rax, 8):
        bufi = buf[i : i + 8]  # little endian: bufi[0] is the least significant byte
    
        bufi[3], bufi[4] = bufi[4], bufi[3]
    
        for j in range(0, min(rax - i, 8)):
            bufi[j] = (j + i + bufi[j]) & 0xff
        _buf = bufi.copy()
        _buf[0] = bufi[5]
        _buf[5] = bufi[0]
        _buf[1] = bufi[7]
        _buf[7] = bufi[1]
        _buf[2] = bufi[6]
        _buf[6] = bufi[2]


        buf[i:i+8] = _buf
    return buf


def encrypt_for(buf: bytearray):
    buf = bytearray(buf)
    _buf = [0] * 6
    _buf[0] = 0xA39C3E6994313F40
    _buf[1] = 0x17872470565B9B60
    _buf[2] = 0x11A918AABA97CA68
    _buf[3] = 0xB8F1B0AB9B3DD3B0
    _buf[4] = 0x488749FB6A1835E4
    _buf[5] = 0x82926F78FE98158

    _buf = (p64(x) for x in _buf)
    _buf = bytearray(b''.join(_buf))

    for i, x in enumerate(buf):
        buf[i] = ((x ^ 0x28) + _buf[i]) & 0xff
    return buf

def decrypt_for(buf: bytearray):
    buf = bytearray(buf)
    _buf = [0] * 6
    _buf[0] = 0xA39C3E6994313F40
    _buf[1] = 0x17872470565B9B60
    _buf[2] = 0x11A918AABA97CA68
    _buf[3] = 0xB8F1B0AB9B3DD3B0
    _buf[4] = 0x488749FB6A1835E4
    _buf[5] = 0x82926F78FE98158

    _buf = (p64(x) for x in _buf)
    _buf = bytearray(b''.join(_buf))

    for i, x in enumerate(buf):
        buf[i] = ((x - _buf[i]) ^ 0x28) & 0xff
    return buf

# test = b'123456781234567812345678123456781234567812345678'
# print(_encrypt_read(test))
# print(encrypt_for(_encrypt_read(test)))

puppet = ELF('./puppet')
peer = ELF('./peer')
size_ = 0x30
ct = puppet.read(puppet.symbols['ct'], size_)
# input_ = b'12345678'
# input_ = b'abcdefgh'
# print(hex(u64(_encrypt_read(input_))))
# exit(0

print("ct",ct)

read_ret = decrypt_for(ct)
print('read_ret',read_ret)
assert ct == encrypt_for(read_ret)

input_ = decrypt_read(read_ret)
print('input_',input_)

assert _encrypt_read(input_) == read_ret
assert len(input_) == size_

with open('input', 'wb') as f:
    f.write(input_)
sh = peer.process()
sh.send(input_)

assert ct == encrypt_for(_encrypt_read(input_))
sh.interactive()