import os
import signal
import subprocess
import threading
import time

# 定义要执行的 adb 命令
adb_template = "adb shell \"su -c 'cat /data/data/de.vidar.run/roman/result.txt'\""


buf = ""

event = threading.Event()
event.clear()


def run():
    global buf
    _t = time.time()
    while True:
        event.wait()
        process = subprocess.Popen(
            adb_template, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )

        output, error = process.communicate()
        print(f"[{len(buf)}] adb finished in {time.time() - _t} seconds")

        output = (
            output.decode()
            .replace(os.linesep, "")
            .replace("\r", "")
            .replace("\x00", "")
        )
        print(buf)
        buf += output
        event.clear()

        if len(buf) > 280:
            break


thr = threading.Thread(target=run)

thr.setDaemon(True)
thr.start()

while thr.is_alive():
    if event.is_set():
        raise TimeoutError("adb timeout")
    event.set()
    time.sleep(1)

print(buf)


assert buf.startswith("!") and buf.endswith(
    "!"
), "plz run the apk till end ! first, then run this script"

buf.lstrip("!").rstrip("!")
buf += "!"

print(buf)


# ceaser cipher

model = "abcdefghijklmnopqrstuvwxyz"

up_model = model.upper()
low_model = model.lower()

for i in range(1, 27):
    str_this_round = ""
    print("key=%d" % i, end="\n")
    for s in buf:
        if s.isalpha():
            if s.isupper():
                model = up_model
            else:
                model = low_model
            n = model.find(s)
            str_this_round += model[n - i]
        else:
            str_this_round += s
    print(str_this_round)
